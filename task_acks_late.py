# ==============================================================================================
# Позднее подтеврждение.
# ==============================================================================================
"""
https://docs.celeryproject.org/en/stable/userguide/configuration.html#std-setting-task_acks_late
Воркер по умолчаню подверждает брокеру очередей, что задача выполнена в тот момент,
когда взял на себя заду. Тогда задача уходит из очереди.
Установив серию парметров acks_late мы меняем это поведение на:
Потверждение и выход из очередит происходит после выполнения работы.

Конечная цель, если у нас выключат свет на серевере воркера - задачи не пропадут и будут исполнены.

По умолчанию, если у брокера пропадает связь с воркером, то он заново ставит те задачи, что есть 
у него в очереди, включая и те, что зарезервированы воркером.
Те задачи, что у воркера, и еще не подтверждены - считаются зарезервированными воркером, 
и храняться в очереди в статусе "невидимости".

"""

# CELERY_ACKS_LATE
#  - Позднее подтверждение означает, 
# что сообщения о задачах будут подтверждены после выполнения задачи, 
# а не непосредственно перед этим (поведение по умолчанию).
# По умолчанию отключено
task_acks_late=False
"""От отключения света никак на спасает - см. следующие параметры ниже"""


# CELERY_TASK_REJECT_ON_WORKER_LOST
# - Когда включено, сообщения для всех задач будут подтверждены, даже если они не пройдут или истекут
# - Если сообщение больше не актулально или вышло по ошибке, то оно считается исполненым
# По умолчанию влючено, работате только при включенном task_acks_late
task_acks_on_failure_or_timeout=True
"""Нас это должно устраивать, т.к. это отлавливаемые моменты на ручном уровне при настройке таска"""


# CELERY_TASK_REJECT_ON_WORKER_LOST
# - отключает суть работы acks_late
"""
Даже если этот параметр task_acks_late включен, 
рабочий процесс будет подтверждать задачи, 
когда выполняющий их рабочий процесс внезапно завершает 
работу или получает сигнал (например, KILL/ INTи т. Д.).
"""
# По умолачанию отключено, если же включено, то внезапные обрывы не будут потдетрждать выполнение.
task_reject_on_worker_lost=False

"""
Предупреждение от разработчиков Celery!!!
Включение этого может вызвать зацикливание сообщений; убедитесь, что вы знаете, что делаете.

К примеру если рабочий получает сигнал (например, KILL/ INTи т. Д.).
Т.е. если мы сами зададим прекращение по жесткому таймауту - задача снова встанет в очередь!
"""

"""Переопределение или запуск локально через таск"""
# Задетс жесткий варинат, вернет в очередь, даже если мы сами его убьем (KILL)
# ---------------------------------------------
@app.task(acks_late=True)
def mytask():
    ...
# ---------------------------------------------

"""
https://docs.celeryproject.org/en/stable/userguide/tasks.html
Если ваша задача идемпотентна, вы можете установить acks_lateопцию, чтобы работник подтвердил сообщение после того, как задача вернется. См. Также раздел часто задаваемых вопросов. Следует ли мне использовать retry или acks_late? .
Обратите внимание, что работник подтвердит сообщение, если дочерний процесс, выполняющий задачу, будет завершен (либо вызовом задачи sys.exit(), либо сигналом), даже если acks_lateон включен. Такое поведение преднамеренно, поскольку…
Мы не хотим повторно запускать задачи, которые заставляют ядро ​​отправлять SIGSEGV(ошибка сегментации) или аналогичные сигналы процессу.
Мы предполагаем, что системный администратор, намеренно завершающий задачу, не хочет ее автоматического перезапуска.
Задача, которая выделяет слишком много памяти, рискует вызвать убийцу OOM ядра, то же самое может произойти снова.
Задача, которая всегда завершается ошибкой при повторной доставке, может вызвать высокочастотный цикл передачи сообщений, приводящий к остановке системы.
Если вы действительно хотите, чтобы задача была повторно доставлена ​​в этих сценариях, вам следует рассмотреть возможность включения этого task_reject_on_worker_lostпараметра.
"""

"""
Хотя. 
Ранее я указал, что это не работает, без изменения дополнительных настроек по умолчанию, 
т.к. мы либо не увидим срыва доч. процессов, либо, те, что мы сами убили - снова придут к нам в очередь.
Но, в случае обрыва света умрет и сам воркер (родительский процесс). 
И все выполняемые задачи будут снова восстановлены из очереди.
Т.е. за срыв будем спрашивать с бати, глобально, а на дочек оставим в покое.
"""